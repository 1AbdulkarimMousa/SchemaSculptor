├── go.mod

////////////////////////////////////////////////////////////////////////////////////////
module github.com/1AbdulkarimMousa/SchemaSculptor/agent

replace github.com/1AbdulkarimMousa/SchemaSculptor/util => ./../util

go 1.22.2

require (
	github.com/1AbdulkarimMousa/SchemaSculptor/util v0.0.0-00010101000000-000000000000
	github.com/lib/pq v1.10.9
)

require (
	github.com/joho/godotenv v1.5.1 // indirect
	golang.org/x/crypto v0.11.0 // indirect
)

////////////////////////////////////////////////////////////////////////////////////////

├── go.sum

////////////////////////////////////////////////////////////////////////////////////////
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
golang.org/x/crypto v0.11.0 h1:6Ewdq3tDic1mg5xRO4milcWCfMVQhI4NkqWWvqejpuA=
golang.org/x/crypto v0.11.0/go.mod h1:xgJhtzW8F9jGdVFWZESrid1U1bjeNy4zgy5cRr/CIio=

////////////////////////////////////////////////////////////////////////////////////////

├── loader.go

////////////////////////////////////////////////////////////////////////////////////////
package agent

import (
	"context"
	"encoding/json"
	"fmt"
)

// LoadSchema loads the database schema
func (sr *SchemaRegistry) LoadSchema(ctx context.Context) error {
	const schemaQuery = `
	-- Return database schema as JSON with table and column information including foreign keys
	SELECT row_to_json(t)
	FROM (
	  -- For each table, get its columns and their properties
	  SELECT 
		c.table_name,
		json_agg(
		  json_build_object(
			'column_name', c.column_name,
			'data_type', c.data_type,
			'is_nullable', c.is_nullable,
			-- Get foreign key references for this column (if any)
			'references', (
			  -- Subquery to find all distinct foreign key references
			  SELECT 
				CASE 
				  WHEN COUNT(*) > 0 THEN 
					-- Use DISTINCT to remove duplicate references
					json_agg(
					  DISTINCT jsonb_build_object(
						'table', ccu.table_name,
						'column', ccu.column_name
					  )
					)
				  ELSE NULL 
				END
			  FROM 
				-- Join tables needed for foreign key information
				information_schema.table_constraints tc
				JOIN information_schema.key_column_usage kcu
				  ON tc.constraint_name = kcu.constraint_name
				  AND tc.table_schema = kcu.table_schema
				JOIN information_schema.constraint_column_usage ccu
				  ON ccu.constraint_name = tc.constraint_name
			  WHERE 
				-- Only include foreign keys
				tc.constraint_type = 'FOREIGN KEY'
				-- That reference this specific column
				AND kcu.table_name = c.table_name
				AND kcu.column_name = c.column_name
				AND tc.table_schema = 'public'
			)
		  ) ORDER BY c.ordinal_position
		) AS columns
	  FROM 
		information_schema.columns c
	  WHERE 
		c.table_schema = 'public'
	  GROUP BY 
		c.table_name
	) t;
	`

	// Execute the query
	rows, err := sr.db.QueryContext(ctx, schemaQuery)
	if err != nil {
		return fmt.Errorf("failed to execute schema query: %w", err)
	}
	defer rows.Close()

	// Process the results
	var tables []Table
	for rows.Next() {
		var jsonData string
		if err := rows.Scan(&jsonData); err != nil {
			return fmt.Errorf("failed to scan row: %w", err)
		}

		var table Table
		if err := json.Unmarshal([]byte(jsonData), &table); err != nil {
			return fmt.Errorf("failed to unmarshal table data: %w", err)
		}

		tables = append(tables, table)
	}

	if err := rows.Err(); err != nil {
		return fmt.Errorf("error iterating rows: %w", err)
	}

	sr.Tables = tables
	return nil
}

////////////////////////////////////////////////////////////////////////////////////////

├── models.go

////////////////////////////////////////////////////////////////////////////////////////
package agent

// Reference represents a foreign key reference
type Reference struct {
	Table  string `json:"table"`
	Column string `json:"column"`
}

// Column represents a database column with its properties
type Column struct {
	Name       string      `json:"column_name"`
	DataType   string      `json:"data_type"`
	IsNullable string      `json:"is_nullable"`
	References []Reference `json:"references"`
}

// Table represents a database table with its columns
type Table struct {
	Name    string   `json:"table_name"`
	Columns []Column `json:"columns"`
}

////////////////////////////////////////////////////////////////////////////////////////

├── print.go

////////////////////////////////////////////////////////////////////////////////////////
package agent

import (
	"fmt"
)

// PrintSchema prints the schema information for debugging
func (sr *SchemaRegistry) PrintSchema() {
	for _, table := range sr.Tables {
		fmt.Printf("Table: %s\n", table.Name)
		for _, column := range table.Columns {
			fmt.Printf("  Column: %s (%s, Nullable: %s)\n",
				column.Name, column.DataType, column.IsNullable)

			if len(column.References) > 0 {
				fmt.Printf("    References:\n")
				for _, ref := range column.References {
					fmt.Printf("      %s.%s\n", ref.Table, ref.Column)
				}
			}
		}
		fmt.Println()
	}
}

////////////////////////////////////////////////////////////////////////////////////////

├── query.go

////////////////////////////////////////////////////////////////////////////////////////
package agent

// GetTable returns a table by name
func (sr *SchemaRegistry) GetTable(name string) (*Table, bool) {
	for i := range sr.Tables {
		if sr.Tables[i].Name == name {
			return &sr.Tables[i], true
		}
	}
	return nil, false
}

// GetColumn returns a column by table and column name
func (sr *SchemaRegistry) GetColumn(tableName, columnName string) (*Column, bool) {
	table, found := sr.GetTable(tableName)
	if !found {
		return nil, false
	}

	for i := range table.Columns {
		if table.Columns[i].Name == columnName {
			return &table.Columns[i], true
		}
	}
	return nil, false
}

// GetReferencingColumns returns all columns that reference a given table and column
func (sr *SchemaRegistry) GetReferencingColumns(tableName, columnName string) []struct {
	Table  *Table
	Column *Column
} {
	var result []struct {
		Table  *Table
		Column *Column
	}

	for i := range sr.Tables {
		table := &sr.Tables[i]
		for j := range table.Columns {
			column := &table.Columns[j]
			for _, ref := range column.References {
				if ref.Table == tableName && ref.Column == columnName {
					result = append(result, struct {
						Table  *Table
						Column *Column
					}{
						Table:  table,
						Column: column,
					})
				}
			}
		}
	}

	return result
}

////////////////////////////////////////////////////////////////////////////////////////

├── registery.go

////////////////////////////////////////////////////////////////////////////////////////
package agent

import (
	"database/sql"
	"fmt"

	"github.com/1AbdulkarimMousa/SchemaSculptor/util"
	_ "github.com/lib/pq"
)

// SchemaRegistry holds the database schema information
type SchemaRegistry struct {
	Tables []Table
	db     *sql.DB
}

// NewSchemaRegistry creates a new schema registry and connects to the database
func NewSchemaRegistry() (*SchemaRegistry, error) {
	// Connect to the database using environment variables
	connStr := fmt.Sprintf(
		"host=%s port=%s dbname=%s user=%s password=%s sslmode=%s",
		util.DBHost, util.DBPort, util.DBName, util.DBUser, util.DBPass, util.DBSSl,
	)

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Test the connection
	if err := db.Ping(); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return &SchemaRegistry{
		db: db,
	}, nil
}

// Close closes the database connection
func (sr *SchemaRegistry) Close() error {
	if sr.db != nil {
		return sr.db.Close()
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////////////

